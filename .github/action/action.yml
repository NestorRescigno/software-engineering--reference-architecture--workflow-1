# *********************************************************************
# *************           IBERIA L.A.E.                   *************
# *************       by Software Engineering             *************
# *********************************************************************
# This action yaml represents the different steps to perform 
# for a deployment in environment with github workflow
# This action'll need a runner to compile and process data for its use.
#
# currently it is only possible to configure 
# two types of languages "java and angular"

name: CICD
description: 'continuos integration'
# setting input
inputs:
  # project name, eguals to product name example ancillaries
  project-name:
    description: 'project global name'
    required: true
  # project name, eguals to product name example ancillaries
  lenguage-code:
    description: 'lenguage  programming code for example: java or angular'
    required: true
    default: 'java'  
  # ejecute integration test, soap request or rest
  testIntegration:
    description: 'active test integration'
    required: false
    default: false
  testIntegration-path:
    description: 'path'
    required: false
    default: '${{ github.workspace }}'
  # control scan code
  scancode:
    description: 'scan code'
    required: true
    default: false
  # control quality code with sonar
  sonarqube-host:
    description: 'sonar host parameter'
    required: false
  sonarqube-user:
    description: 'sonar user parameter'
    required: false
  sonarqube-token:
    description: 'sonar token parameter'
    required: false
  sonarqube-client-version:
    description: 'sonar-scanner client version parameter v.r.f.build'
    required: false
  # control vulnerability code with kiuwan
  kiuwan-host:
    description: 'kiuwan host parameter'
    required: false
  kiuwan-user:
    description: 'kiuwan user parameter'
    required: false
  kiuwan-token:
    description: 'kiuwan token parameter'
    required: false
   # control vulnerability code with kiuwan
  repository-host:
    description: 'repository artifact host parameter'
    required: true
  repository-user:
    description: 'repository artifact user parameter'
    required: true
  repository-token:
    description: 'repository artifact token parameter'
    required: true  

  # configuration cloud secret by enviroment
  aws-access-key:
    description: 'access key aws publish environment'
    required: true
  aws-secret-acesss-key:
    description: 'secret access key aws publish environment'
    required: true
  aws-access-key-dev:
    description: 'access key aws development environment'
    required: true
  aws-secret-acesss-key-dev:
    description: 'secret access key aws development environment'
    required: true

on: [pull_request]
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:    
      - main
      - develop
jobs:
  build:
    name: build
    runs-on: [self-hosted]
    # setting output step build to use other jobs steps
    outputs:
      package-groupid-name:
        description: "Package build generator Group Id"
        value: ${{ steps.package-generator-name.outputs.package-group }}
      package-artifactid-name:
        description: "Package build generator artifact Id"
        value: ${{ steps.package-generator-name.outputs.package-artifact }}
      package-version-name:
        description: "Package build generator version"
        value: ${{ steps.package-generator-name.outputs.package-version }} 
      package-type-name:
        description: "package type example: jar, war, zip"
        value: ${{ steps.package-generator-name.outputs.package-type-id }}
      package-repository:
        description: "package repository path"
        value: ${{ steps.registry-repository.outputs.registry-repository-id }}    
    env:
      SCRIPT: ${{ github.workspace }}/.github/action/utils/
      LANGUAGE: ${{ inputs.lenguage-code }}
    steps:
      # Nota: 
      # Remplace action's with custom shell script to future
      # for segurity - location in (../utils/)
      # Step 1 
      - name: checkout
        uses: actions/checkout@v2
      # Step 2 - Reemplace with install process jdk and configure path environment
      - name: Set up JDK 11
        uses: actions/setup-java@v2
        with:
          java-version: '11'
          distribution: 'adopt'
      # Step 3 - Reemplace with install process node.js
      - name: Set up Node 14
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      # Step 4 
      - name: Building Artifact
        id: package-generator-name
        shell: bash
        run: |
        ${{ env.SCRIPT }}/build.sh
      # Step 5  
      - name: control
        id: control-version
        shell: bash
        env:
          VERSION:  ${{ jobs.build.outputs.package-version-name }}   # get package name generate from step build
        run: |
        ${{ env.SCRIPT }}/control-version.sh
    steps:
      # implement sonar
      # Step 1
      - name: Scan
        shell: bash
        env:
          GROUP:  ${{ jobs.build.outputs.package-groupid-name }}   # get package name generate from step build
          ARTIFACT:  ${{ jobs.build.outputs.package-artifactid-name }}   # get package name generate from step build
          VERSION:  ${{ jobs.build.outputs.package-version-name }}   # get package name generate from step build
          PACKAGE: ${{ jobs.build.outputs.package-type-name }} # get package type extention from step build
          SONAR_URL: inputs.sonarqube-host
          SONAR_USER: inputs.sonarqube-user
          SONAR_SECRET: inputs.sonarqube-token
          SONAR_CLI: inputs.sonarqube-client-version
        run: |
        ${{ env.SCRIPT }}/sonar-scanner.sh
    steps:
      # deploy artifact to registry repository
      - name: Registy artifact
        id: registry-repository
        shell: bash
        env:
          GROUP:  ${{ jobs.build.outputs.package-groupid-name }}   # get package name generate from step build
          ARTIFACT:  ${{ jobs.build.outputs.package-artifactid-name }}   # get package name generate from step build
          VERSION:  ${{ jobs.build.outputs.package-version-name }}   # get package name generate from step build
          PACKAGE: ${{ jobs.build.outputs.package-type-name }} # get package type extention from step build
          # DNS hasn't content http:// or https://
          REPOSITORY_DNS: inputs.repository-host
          REPOSITORY_USER: inputs.repository-user
          REPOSITORY_SECRET: inputs.repository-token
        run: |
        ${{ env.SCRIPT }}/nexus-registry.sh
  environment:
    name: environment
    runs-on: [self-hosted]
    outputs:
      security-group-number-ids:
        description: "security groups numbers ids"
        value: ${{ steps.build-environment-generator.security-group-ids }}
      subnet-number-ids:
        description: "subnets numbers ids"
        value: ${{ steps.build-environment-generator.subnets-ids }}
      alb-target-group-number-arn:
        description: "load balancer targer group numbers ids"
        value: ${{ steps.build-environment-generator.alb-target-group-arn }}
    env:
      SCRIPT: ${{ github.workspace }}/.github/action/utils/
      PROJECT:  ${{ inputs.project-name }}   # get input name, this name use in dns site and global value. project = product business
      GROUP:  ${{ jobs.build.outputs.package-groupid-name }}   # get package name generate from step build
      SERVICE:  ${{ jobs.build.outputs.package-artifactid-name }}
      WORKSPACE: ${{ github.workspace }}
      REF:  ${{ github.ref }}
      # input account integration/preproduction environment
      AWS_ACCESS_KEY: ${{ inputs.aws-access-key }}
      AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
      # input account development environment
      AWS_ACCESS_KEY_DEV: ${{ inputs.aws-access-key-dev }}
      AWS_SECRET_ACCESS_KEY_DEV: ${{ inputs.aws-secret-access-key-dev }}
    steps:
      # build image
      # Step 1
      - name: build image
        id: build-environment-generator
        shell: bash
        run: |
        ${{ env.SCRIPT }}/build-environment.sh
  image:
    name: image
    runs-on: [self-hosted]
    outputs:
      image-number-id:
        description: "image number id"
        value: ${{ steps.image-generator.outputs.image-id }}
    env:
      SCRIPT: ${{ github.workspace }}/.github/action/utils/
      LANGUAGE: ${{ inputs.lenguage-code }}
      PROJECT:  ${{ inputs.project-name }}   # get input name, this name use in dns site and global value. project = product business
      GROUP:  ${{ jobs.build.outputs.package-groupid-name }}   # get package name generate from step build
      ARTIFACT:  ${{ jobs.build.outputs.package-artifactid-name }}   # get package name generate fromstep build
      VERSION:  ${{ jobs.build.outputs.package-version-name }}   # get package name generate from step build
      PACKAGE: ${{ jobs.build.outputs.package-type-name }} # get package type extention from step build
      REPOSITORY_PATH:  ${{ jobs.build.outputs.package-repository }}   # get path repository package generate font step build
      REPOSITORY_HOST: inputs.repository-host
      REPOSITORY_USER: inputs.repository-user    # change user to read, now use write
      REPOSITORY_SECRET: inputs.repository-token   # change token to read, now use write
      SECURITY_GROUPS: ${{ jobs.environment.outputs.security-group-number-ids }}
      SUBNETS: ${{ jobs.environment.outputs.subnet-number-ids }}
      # secret account operational. it isn't present in input but en secret repository owner.
      AWS_ACCESS_KEY_OP: ${{secret.aws-access-key-op}}                   
      AWS_SECRET_ACCESS_KEY_OP: ${{ secret.aws-secret-access-key-op}}
      # input account development environment
      AWS_ACCESS_KEY_DEV: ${{ inputs.aws-access-key-dev }}
      AWS_SECRET_ACCESS_KEY_DEV: ${{ inputs.aws-secret-access-key-dev }}
    steps:
      # build image
      # Step 1
      - name: build image
        id: image-generator
        shell: bash
        run: |
        ${{ env.SCRIPT }}/build-image.sh
  deploy:
    name: deploy
    runs-on: [self-hosted]
    env:
      SCRIPT: ${{ github.workspace }}/.github/action/utils/
      TEST: inputs.testIntegration
      LANGUAGE: ${{ inputs.lenguage-code }}
      AMI_ID: ${{ jobs.image.outputs.image-number-id }}
      PROJECT:  ${{ inputs.project-name }}   # get input name, this name use in dns site and global value. project = product business
      AMI_VERSION:  ${{ jobs.build.outputs.package-version-name }}   # get package version generate from step build
      SECURITY_GROUPS: ${{ jobs.environment.outputs.security-group-number-ids }}
      SUBNETS: ${{ jobs.environment.outputs.subnet-number-ids }}
      ALB_TARGET_GROUP: ${{ jobs.environment.outputs.alb-target-group-number-arn}}
      # input account integration/preproduction environment
      AWS_ACCESS_KEY: ${{ inputs.aws-access-key }}
      AWS_SECRET_ACCESS_KEY: ${{ inputs.aws-secret-access-key }}
    if: ${{ startsWith(${ github.ref }, 'refs/heads/main') == true }} 
    steps:
      # instance software.
      # Step 1
      - name: Deploy
        shell: bash
        run: |
        ${{ env.SCRIPT }}/terraform-deploy.sh 
      # Step 2
      - name: Health Check
        shell: bash
        run: |
        ${{ env.SCRIPT }}/health-checking.sh
      # Step 3
      - name: Integration tests
        shell: bash
        run: |
        ${{ env.SCRIPT }}/integration-tests.sh 
  # create de tag release en github. use same release and put image id in description or release note. necessary to next environment 
  # NOTE OF DEVELOPER: pending release process
  tagging:
    name: tagging
    runs-on: [self-hosted]      
    env:
      TAG: ${{ jobs.build.outputs.package-version-name }}   # version artifact  = VERSION  
      RELEASE:  ${{ jobs.build.outputs.package-version-name }}  # funtional version of product. now default use tag version.
      BODY: "build image id: ${{ jobs.image.outputs.image-number-id }}"
      run: |
        # pending code. 
        # git tag ${TAG}
  # clean workspace and other reference. end process. NOTE OF DEVELOPER: pending clean
  # clean:
  #   name: clean
  #   runs-on: [self-hosted]
